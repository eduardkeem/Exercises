
        function power(base, exp) {
            if (exp == 0) {
                return 1;
            } else if (exp == 1) {
                return base;
            } else {
                return base * power(base, exp - 1);
            }
        }
        console.log(power(2, 3));

/*
@AlexandrKazakov Смотрите. Вы вызываете функцию с параметрами (2,3). Она в свою очередь вызывает вторую копию функции, на сей раз с параметрами (2,2). Та вызовет третью копию, с параметрами (2,1). Третья копия вернёт значение (сработает альтернативная ветка в IF), равное первому параметра, т.е. 2. Вторая копия получит его, продолжит вычисление выражения, умножит 2 на 2 и вернёт в первую копию 4. Та произведёт умножение 2 на 4 и вернёт в основную программу 8. –
Akina
 2 фев 2017 в 5:44
@Akina спасибо! ваше объяснение про копии мне помогло понять, хотя до этого я читал достаточно много других объяснений. Иначе говоря внешняя функция не может выполниться пока не выполнится внутренняя(которую она вызывает). Получается три уровня вложенности; третий останавливается из-за заданного условия (n != 1), и возвращает 2(наш x), третий уровень вернул двойку второму, далее второй выполняет *= т. е. умножение на два, второй уровень получает 4 и возвращает первому и первый умножает на два и возвращает 8 в alert. Это очень интересно! –
Александр Казаков
 2 фев 2017 в 6:33
1
@AlexandrKazakov Одна только ремарка. Функция вообще-то содержит серьёзную ошибку. Представьте, что мы имели глупость попросить вычислить pow(2, 2.5)... Условие следует изменить, например, на if (n < 2) {return x *= pow(x,n - 1);} else {return 1;}. Причём подобная фигня может быть и ненамеренной - например, аргумент может вычисляться выражением как число с плавающей точкой, и вместо ожидаемого, например, 3, у нас получится вторым аргументом какое-нибудь 2.999999997
*/
