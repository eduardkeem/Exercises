
        /*
        Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы массива.
        Многократные прогоны через shuffle могут привести к разным последовательностям элементов. Например:

        let arr = [1, 2, 3];

        shuffle(arr);
        // arr = [3, 2, 1]

        shuffle(arr);
        // arr = [2, 1, 3]

        shuffle(arr);
        // arr = [3, 1, 2]
        // ...
        Все последовательности элементов должны иметь одинаковую вероятность. 
        Например, [1,2,3] может быть переупорядочено как [1,2,3] или [1,3,2], или [3,1,2] и т.д., 
        с равной вероятностью каждого случая.
        */


        let arr = [1, 2, 3];


        function shuffle(value) {
            return value.sort(() => Math.random() - 0.5);
        }

        console.log(arr);
        console.log(shuffle(arr));


        /*Это, конечно, будет работать, потому что Math.random() - 0.5 отдаёт случайное число, которое может быть положительным 
        или отрицательным, следовательно, функция сортировки меняет порядок элементов случайным образом.
        Но поскольку метод sort не предназначен для использования в таких случаях, не все возможные варианты имеют одинаковую вероятность.
        Например, рассмотрим код ниже. Он запускает shuffle 1000000 раз и считает вероятность появления для всех возможных вариантов arr:
        */

        function shuffle(array) {
        array.sort(() => Math.random() - 0.5);
        }

        // подсчёт вероятности для всех возможных вариантов
        let count = {
        '123': 0,
        '132': 0,
        '213': 0,
        '231': 0,
        '321': 0,
        '312': 0
        };

        for (let i = 0; i < 1000000; i++) {
            let array = [1, 2, 3];
            shuffle(array);
            count[array.join('')]++;
        }

        // показать количество всех возможных вариантов
        for (let key in count) {
        alert(`${key}: ${count[key]}`);
        }

        // Результат примера (зависят от движка JS):

                // 123: 250706
                // 132: 124425
                // 213: 249618
                // 231: 124880
                // 312: 125148
                // 321: 125223


          /*    Теперь мы отчётливо видим допущенное отклонение: 123 и 213 появляются намного чаще, чем остальные варианты.
                Результаты этого кода могут варьироваться при запуске на разных движках JavaScript, но очевидно, 
                что такой подход не надёжен. Так почему это не работает? Если говорить простыми словами, то sort 
                это «чёрный ящик»: мы бросаем в него массив и функцию сравнения, ожидая получить отсортированный массив. 
                Но из-за абсолютной хаотичности сравнений чёрный ящик сходит с ума, и как именно он сходит с ума, 
                зависит от конкретной его реализации, которая различна в разных движках JavaScript.
                Есть и другие хорошие способы решить эту задачу. Например, есть отличный алгоритм под названием Тасование Фишера — Йетса. 
                Суть заключается в том, чтобы проходить по массиву в обратном порядке и менять местами каждый элемент со случайным элементом, 
                который находится перед ним.
        */

        function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i

            // поменять элементы местами
            // мы используем для этого синтаксис "деструктурирующее присваивание"
            // подробнее о нём - в следующих главах
            // то же самое можно записать как:
            // let t = array[i]; array[i] = array[j]; array[j] = t
            [array[i], array[j]] = [array[j], array[i]];
        }
        }

        // Давайте проверим эту реализацию на том же примере:

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            }

            // подсчёт вероятности для всех возможных вариантов
            // let count = {
            // '123': 0,
            // '132': 0,
            // '213': 0,
            // '231': 0,
            // '321': 0,
            // '312': 0
            // };

            for (let i = 0; i < 1000000; i++) {
            let array = [1, 2, 3];
            shuffle(array);
            count[array.join('')]++;
            }

            // показать количество всех возможных вариантов
            for (let key in count) {
            alert(`${key}: ${count[key]}`);

            }

            // Пример вывода:

            // 123: 166693
            // 132: 166647
            // 213: 166628
            // 231: 167517
            // 312: 166199
            // 321: 166316

/*
        Теперь всё в порядке: все варианты появляются с одинаковой вероятностью.
        Кроме того, если посмотреть с точки зрения производительности, то алгоритм «Тасование Фишера — Йетса» 
        намного быстрее, так как в нём нет лишних затрат на сортировку.
*/
